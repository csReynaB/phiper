% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prevalence-POP-test.R
\name{ph_prevalence_compare}
\alias{ph_prevalence_compare}
\title{Prevalence by group with pairwise tests (POP; per-rank FDR; BH & weighted BH)}
\usage{
ph_prevalence_compare(
  x,
  rank_cols,
  group_cols,
  exist_col = "exist",
  weight_mode = c("peptide_count", "none"),
  parallel = NULL,
  compute_ratios_db = TRUE,
  interaction = FALSE,
  combine_cols = NULL,
  interaction_sep = "::",
  collect = TRUE,
  register_name = NULL,
  pop_k_min = 1L,
  paired = FALSE,
  peptide_library = NULL
)
}
\arguments{
\item{x}{A \code{phip_data} object with DuckDB backend \strong{or} a data.frame/tibble
with at least: \code{sample_id}, \code{peptide_id}, \code{exist_col}, all \code{group_cols}, and
if \code{paired=TRUE} also \code{subject_id}. If \code{rank_cols} include non-peptide taxa,
\code{x} must provide \code{peptide_library} with those columns.}

\item{rank_cols}{Character vector of rank columns, e.g. \code{c("peptide_id","species")}.}

\item{group_cols}{Character vector of grouping columns defining universes.}

\item{exist_col}{Name of the binary presence column (default \code{"exist"}).}

\item{weight_mode}{\code{"peptide_count"} (default) or \code{"none"}.}

\item{parallel}{Logical; compute Fisher p-values in parallel if possible (default \code{NULL} = auto).}

\item{compute_ratios_db}{Logical; compute simple ratios/delta ratios in SQL (unpaired only).}

\item{interaction}{Logical; also create an interaction universe of the first two \code{group_cols}.}

\item{combine_cols}{Optional length-2 character vector to build only that interaction universe.}

\item{interaction_sep}{Separator for interaction labels (default \code{"::"}).}

\item{collect}{Logical; if \code{TRUE} (default) return a collected tibble; otherwise a lazy table.}

\item{register_name}{Optional DuckDB table name for materialization (unpaired path).}

\item{pop_k_min}{Integer ≥1; k-of-n POP threshold per sample (default 1).}

\item{paired}{Logical; use paired design (McNemar exact) with \code{subject_id} (default \code{FALSE}).
NOTE: can also be a character scalar naming the column that links related samples
(e.g. "subject_id" or "dyade"). If so, only samples present in both groups
for that identifier will be used for paired McNemar tests.}
}
\value{
An object of class \code{ph_prev_result}, i.e., a tibble (or lazy table if
\code{collect = FALSE} on the unpaired path) with attributes:
\itemize{
\item \code{prev_meta$m_by_rank}: named integer vector of \code{m_r} per rank,
\item \code{prev_meta$pairs_by_universe}: tibble with \code{group_col}, \code{k_levels}, \code{n_pairs},
\item \code{prev_meta$pool_by_rank}: tibble with \code{rank}, \code{POOL},
\item other bookkeeping: \code{paired}, \code{weight_mode}, \code{pop_k_min}, \code{fdr_scope = "per-rank"},
\item \code{register_name} (unpaired path) and \code{view} (if available).
}

Columns include (subset may differ between paths): \code{view}, \code{rank}, \code{feature},
\code{n_peptides}, \code{group_col}, \code{group1}, \code{group2}, \code{n1}, \code{N1}, \code{prop1}, \code{percent1},
\code{n2}, \code{N2}, \code{prop2}, \code{percent2}, optional \code{ratio}, \code{delta_ratio}, \code{p_raw},
\code{p_adj_rank}, \code{passed_rank_bh}, \code{category_rank_bh}, \code{p_adj_rank_wbh},
\code{passed_rank_wbh}, \code{category_rank_wbh}.
}
\description{
Computes prevalence (counts, proportions, percentages) for features defined by
the requested \code{rank_cols} across one or more grouping "universes" (\code{group_cols},
optional interaction), and performs \strong{pairwise} statistical tests between all
group levels. Presence is computed with a k-of-n POP rule within each sample
(\code{pop_k_min}, default 1). Two testing modes are supported:
\itemize{
\item \strong{Unpaired:} Fisher’s exact test (2×2) per (rank, feature, group pair).
\item \strong{Paired:} McNemar’s exact (binomial) per subject (\code{paired = TRUE} requires
\code{subject_id}).
}

P-values are adjusted \strong{per rank} (single FDR family for each rank across all
requested universes/pairs/features) using BH and optional weighted BH
(\code{weight_mode = "peptide_count"}).
}
\details{
\strong{universe construction.} For each \code{group_col} we create a universe of levels
present in the data (non-missing). If \code{interaction = TRUE} (or \code{combine_cols} is
provided), we also build a combined universe where the group value is
\verb{<col1>::<col2>}. Denominators \code{N} are distinct sample counts per
\verb{(group_col, group_value)}.

\strong{presence (pop).} For each sample and each \verb{(rank, feature)}, we count the
number of positive peptides contributing to that feature; a feature is marked
present if \code{k >= pop_k_min} (default 1). This yields \code{n_present} per
\verb{(group_col, group_value, rank, feature)} and prevalence \code{prop = n_present / N}.

\strong{pairwise tests.} For each universe with \code{K} levels we form all unordered
pairs \code{K*(K-1)/2}. For each \verb{(rank, feature, pair)}:
\itemize{
\item unpaired: build the 2×2 table from (\code{n1}, \code{N1 - n1}, \code{n2}, \code{N2 - n2}) and run
Fisher’s exact test (two-sided).
\item paired: compute discordant counts \verb{(n01, n10)} per subject and run
McNemar’s exact binomial test (\code{binom.test(n01, n01+n10)}).
}

\strong{fdr families and the number of comparisons.}
Let \code{POOL_r} be the number of unique features for a given \strong{rank} \code{r}
\strong{across all requested universes} (after presence aggregation and any missing
value filtering). Let \verb{PAIRS = sum_u K_u*(K_u-1)/2} be the total number of
unordered level-pairs summed over all universes \code{u} (each \code{u} is one
\code{group_col} or an interaction universe). Then the size of the \strong{single FDR
family} for rank \code{r} is:

\deqn{ m_r \;=\; POOL_r \times PAIRS. }

All p-values produced for rank \code{r} (covering \strong{all} universes and \strong{all}
level pairs) are adjusted together as one family of size \code{m_r}. This makes the
per-rank FDR \strong{stricter} when (i) there are many features for that rank, and/or
(ii) many universes or levels generate many pairwise comparisons.

\strong{bh (benjamini–hochberg).} Within each rank \code{r} (and \code{view} if present),
BH q-values are computed via \code{p.adjust(method="BH")} on the vector of p-values
of length \code{m_r} (excluding NAs). Reported columns:
\code{p_adj_rank}, \code{passed_rank_bh}, \code{category_rank_bh}.

\strong{weighted bh.} If \code{weight_mode="peptide_count"}, each \verb{(rank,feature)} gets a
base weight equal to the number of distinct peptides mapping to that feature.
Within each rank \code{r} (and \code{view} if present), \strong{weights are scaled to sum to}
\code{m_r}:

\deqn{ w_i^\* \;=\; w_i \cdot \frac{m_r}{\sum_j w_j}. }

We adjust using the standard weighted step-up rule on \verb{p_i / w_i^\\*}. The
resulting q-values are reported in \code{p_adj_rank_wbh}, with flags
\code{passed_rank_wbh} and labels \code{category_rank_wbh}. If \code{weight_mode="none"},
all weights are 1 and wBH reduces to BH.

\strong{logging of comparisons.} The function logs:
\itemize{
\item \code{POOL_r} per rank,
\item number of levels \code{K_u} and pair counts per universe,
\item \verb{PAIRS = sum_u K_u*(K_u-1)/2},
\item \code{m_r = POOL_r * PAIRS} for each rank.
These values are also returned in the object metadata (see Value).
}
}
\examples{
\dontrun{
res <- ph_prevalence_compare(pd, rank_cols=c("species"), group_cols=c("big_group"))
print(res)
}

}
