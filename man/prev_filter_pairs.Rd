% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prevalence-POP-test.R
\name{prev_filter_pairs}
\alias{prev_filter_pairs}
\title{Filter pairwise results by groups/ranks/features with optional q-value gates}
\usage{
prev_filter_pairs(
  df,
  gA,
  gB,
  ranks = NULL,
  features = NULL,
  features_regex = FALSE,
  group_universe = NULL,
  universe_regex = FALSE,
  col_rank = "rank",
  col_feature = "feature",
  col_g1 = "group1",
  col_g2 = "group2",
  col_groupcol = "group_col",
  p_raw_max = NULL,
  q_bh_max = NULL,
  q_wbh_max = NULL,
  passed_only = FALSE,
  drop_na = TRUE,
  keep_cols = NULL
)
}
\arguments{
\item{df}{A \code{ph_prev_result} or \code{data.frame} with columns \code{group1}, \code{group2}
and optionally \code{group_col}, \code{rank}, \code{feature}, p/q columns.}

\item{gA, gB}{character vector or length-1 character (pojedyncza para). Można
też przekazać listę par (np. \code{list(c("B","M12"), c("T0","T2"))}) albo
dwu-kolumnowy \code{data.frame}/\code{tibble} z nazwami kolumn \code{gA}, \code{gB}.}

\item{ranks}{Optional character vector of ranks to keep.}

\item{features}{Optional character vector or regex pattern(s).}

\item{features_regex}{Logical; treat \code{features} as regex pattern(s) (OR).}

\item{group_universe}{Optional character vector or regex pattern(s) for \code{group_col}.}

\item{universe_regex}{Logical; treat \code{group_universe} as regex pattern(s) (OR).}

\item{col_rank, col_feature, col_g1, col_g2, col_groupcol}{Column names in \code{df}.}

\item{p_raw_max, q_bh_max, q_wbh_max}{Optional numeric thresholds (e.g. 0.05).}

\item{passed_only}{Logical; if TRUE, keep rows with any \verb{passed_* == TRUE} found.}

\item{drop_na}{Logical; drop rows with NA in group1/group2 before pair match.}

\item{keep_cols}{Optional character vector of columns to retain (NULL = all).}
}
\value{
Filtered object of the same base type as \code{df}; if input is a
\code{ph_prev_result}, output keeps the class and augmented metadata.
}
\description{
Order-agnostic filter for rows comparing two group levels (e.g. "B" vs "M12"),
z opcjonalnym zawężeniem do ranków/feature'ów/uniwersów oraz progów istotności.
Działa zarówno na obiekcie klasy \code{ph_prev_result}, jak i zwykłym \code{data.frame}.
}
\details{
\strong{pary grup (symetrycznie).} Dla każdej zadanej pary \{gA, gB\} dobierane są
wiersze, w których \verb{(min(group1,group2), max(group1,group2))} zgadza się z
\code{sort(c(gA, gB))}, niezależnie od kolejności w danych.

\strong{filtrowanie.}
\itemize{
\item \code{ranks}: wektor rang do zatrzymania.
\item \code{features}: wektor lub regex; jeśli \code{features_regex=TRUE}, wszystkie wzorce
są łączone logicznym OR (dopasowanie nieczułe na wielkość liter).
\item \code{group_universe}: dokładne wartości \code{group_col} albo regex (gdy
\code{universe_regex=TRUE}).
\item progi istotności: \code{p_raw_max}, \code{q_bh_max}, \code{q_wbh_max} oraz \code{passed_only}
(korzysta z kolumn \code{passed_rank_bh}/\code{passed_rank_wbh}, jeśli są dostępne).
}

\strong{klasa.} Jeżeli wejście ma klasę \code{ph_prev_result}, wyjście zachowuje ją oraz
atrybut \code{prev_meta} (dodaje \code{subsetted = TRUE}, oraz ewentualną notkę o filtrze).
}
\examples{
\dontrun{
# single pair, regex on features:
# prev_filter_pairs(res, "B", "M12", ranks = "species",
#                   features = "flagellin|fliC", features_regex = TRUE,
#                   q_bh_max = 0.1)

# multiple pairs:
# pairs <- list(c("B","M12"), c("T0","T2"))
# prev_filter_pairs(res, pairs[[1]][1], pairs[[1]][2], ranks="peptide_id")
}

}
